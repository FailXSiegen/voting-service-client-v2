# GitLab CI f√ºr Server-Runner (Shell Executor)
# Verwendet den lokal installierten Runner auf dem voting.failx.de Server

# Backup Job f√ºr Server-Runner
backup_database_server:
  stage: test-prepare
  script:
    - echo "üì¶ Erstelle Datenbank-Backup (Server-Runner)..."
    - |
      # Verwende DEPLOY_PATH aus GitLab CI Variablen
      DEPLOY_PATH="/var/www/html/voting-tool"
      
      # Pr√ºfe ob Verzeichnis existiert und zug√§nglich ist
      if [ ! -d "$DEPLOY_PATH" ]; then
        echo "‚ö†Ô∏è Deployment-Verzeichnis nicht gefunden: $DEPLOY_PATH"
        echo "Erstelle Verzeichnis und setze Berechtigungen..."
        
        # Erstelle Verzeichnis-Struktur
        sudo mkdir -p "$DEPLOY_PATH"
        sudo mkdir -p /var/www/html/voting-tool-backups
        
        # Setze Berechtigungen f√ºr gitlab-runner
        sudo chown -R gitlab-runner:gitlab-runner "$DEPLOY_PATH"
        sudo chown -R gitlab-runner:gitlab-runner /var/www/html/voting-tool-backups
        
        echo "‚úÖ Verzeichnis erstellt und Berechtigungen gesetzt"
      fi
      
      # Pr√ºfe ob docker-compose.yml existiert
      if [ ! -f "$DEPLOY_PATH/docker-compose.yml" ]; then
        echo "‚ö†Ô∏è docker-compose.yml nicht gefunden in $DEPLOY_PATH"
        echo "M√∂gliche L√∂sungen:"
        echo "1. F√ºhre zuerst den 'deploy' Job in GitLab aus"
        echo "2. Oder versuche direkte Docker-Container-Kommunikation"
        
        # Fallback: Versuche Docker-Container direkt anzusprechen
        echo "Versuche Docker-Container direkt zu finden..."
        VOTING_CONTAINERS=$(docker ps --format "{{.Names}}" | grep -E "(voting|db)" | head -5)
        if [ -n "$VOTING_CONTAINERS" ]; then
          echo "Gefundene voting-relevante Container:"
          echo "$VOTING_CONTAINERS"
          
          # Suche nach DB-Container (erweiterte Suche)
          DB_CONTAINER=$(docker ps --format "{{.Names}}" | grep -E "(db|mysql|database|mariadb)" | head -1)
          
          # Fallback: Suche nach voting_db Container
          if [ -z "$DB_CONTAINER" ]; then
            DB_CONTAINER=$(docker ps --format "{{.Names}}" | grep "voting.*db" | head -1)
          fi
          if [ -n "$DB_CONTAINER" ]; then
            echo "‚úÖ DB-Container gefunden: $DB_CONTAINER"
            
            # Verwende Container-Namen statt docker-compose
            BACKUP_DIR="/var/www/html/voting-tool-backups"
            mkdir -p "$BACKUP_DIR"
            
            BACKUP_TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            BACKUP_FILE="$BACKUP_DIR/voting-db-backup-${BACKUP_TIMESTAMP}.sql"
            
            echo "Erstelle Backup via Container: $DB_CONTAINER"
            docker exec "$DB_CONTAINER" mysqldump -u root -p${VOTING_DB_ROOT_PASSWORD:-root_password} ${VOTING_DB_NAME:-voting_db} > "$BACKUP_FILE"
            
            if [ -s "$BACKUP_FILE" ]; then
              echo "‚úÖ Backup erfolgreich erstellt: $BACKUP_FILE"
              echo "BACKUP_FILE=$BACKUP_FILE" > backup-info.env
              echo "BACKUP_TIMESTAMP=$BACKUP_TIMESTAMP" >> backup-info.env
              exit 0
            else
              echo "‚ùå Backup via Container fehlgeschlagen"
              exit 1
            fi
          fi
        fi
        
        echo "‚ùå Keine voting-tool Installation oder Container gefunden!"
        echo "F√ºhre zuerst den 'deploy' Job aus oder pr√ºfe Docker-Setup"
        exit 1
      fi
      
      # Normalfall: Wechsle ins Deployment-Verzeichnis
      cd "$DEPLOY_PATH"
      
      # Backup-Verzeichnis erstellen
      mkdir -p /var/www/html/voting-tool-backups
      
      # Timestamp f√ºr Backup
      export BACKUP_TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      export BACKUP_FILE="/var/www/html/voting-tool-backups/voting-db-backup-${BACKUP_TIMESTAMP}.sql"
      
      # Pr√ºfe Docker Compose Status
      echo "Docker Compose Status:"
      docker compose ps
      
      # Erstelle Backup
      echo "Erstelle Backup: ${BACKUP_FILE}"
      docker compose exec -T db mysqldump -u root -p${VOTING_DB_ROOT_PASSWORD:-root_password} ${VOTING_DB_NAME:-voting_db} > "${BACKUP_FILE}"
      
      # Pr√ºfe Backup
      if [ -s "${BACKUP_FILE}" ]; then
        echo "‚úÖ Backup erfolgreich erstellt: ${BACKUP_FILE}"
        echo "Backup-Gr√∂√üe: $(du -h ${BACKUP_FILE} | cut -f1)"
        
        # Speichere Info f√ºr nachfolgende Jobs
        echo "BACKUP_FILE=${BACKUP_FILE}" > backup-info.env
        echo "BACKUP_TIMESTAMP=${BACKUP_TIMESTAMP}" >> backup-info.env
      else
        echo "‚ùå Backup fehlgeschlagen!"
        exit 1
      fi
  artifacts:
    reports:
      dotenv: backup-info.env
    expire_in: 1 week
  when: manual
  only:
    - main
  tags:
    - server  # Nur auf Server-Runner ausf√ºhren

# Import Job f√ºr Server-Runner  
import_test_data_server:
  stage: test-prepare
  script:
    - echo "üì• Importiere Testdaten (Server-Runner)..."
    - |
      # Verwende SQL-Datei aus GitLab Runner Working Directory
      echo "Current working directory: $(pwd)"
      echo "Available files:"
      ls -la
      
      # Pr√ºfe ob SQL-Datei existiert (im Runner Working Directory)
      if [ ! -f "test-data/load-test-scenario.sql" ]; then
        echo "‚ùå SQL-Datei nicht gefunden!"
        echo "Verf√ºgbare Dateien:"
        find . -name "*.sql" -type f || echo "Keine SQL-Dateien gefunden"
        exit 1
      fi
      
      # Wechsle ins voting-tool Deployment-Verzeichnis f√ºr Docker-Compose
      cd /var/www/html/voting-tool
      
      # Docker Compose Status pr√ºfen
      echo "Docker Compose Status:"
      docker compose ps
      
      # Importiere Testdaten (verwende SQL-Datei aus Runner Working Directory)
      echo "Importiere SQL-Daten..."
      docker compose exec -T db mysql -u root -p${VOTING_DB_ROOT_PASSWORD:-root_password} ${VOTING_DB_NAME:-voting_db} < ${CI_PROJECT_DIR}/test-data/load-test-scenario.sql
      
      if [ $? -eq 0 ]; then
        echo "‚úÖ Testdaten erfolgreich importiert"
        
        # Pr√ºfe importierte Daten
        USER_COUNT=$(docker compose exec -T db mysql -u root -p${VOTING_DB_ROOT_PASSWORD:-root_password} ${VOTING_DB_NAME:-voting_db} -e "SELECT COUNT(*) FROM event_user WHERE event_id = (SELECT id FROM event WHERE slug = 'lasttest-2025');" -N 2>/dev/null)
        echo "Importierte Testnutzer: ${USER_COUNT}"
        
        # Speichere Event-Informationen
        echo "TEST_EVENT_SLUG=lasttest-2025" > test-info.env
        echo "TEST_EVENT_URL=https://voting.failx.de/#/register/lasttest-2025" >> test-info.env
        echo "TEST_USER_COUNT=${USER_COUNT}" >> test-info.env
      else
        echo "‚ùå Import fehlgeschlagen!"
        exit 1
      fi
  artifacts:
    reports:
      dotenv: test-info.env
    expire_in: 1 week
  needs:
    - backup_database_server
  when: manual
  only:
    - main
  tags:
    - server

# Restore Job f√ºr Server-Runner
restore_database_server:
  stage: test-cleanup
  script:
    - echo "‚ôªÔ∏è Stelle Datenbank wieder her (Server-Runner)..."
    - |
      # Wechsle ins voting-tool Verzeichnis
      cd /var/www/html/voting-tool
      
      # Verwende Backup-File aus vorherigem Job oder suche neuestes
      if [ -z "${BACKUP_FILE}" ]; then
        echo "Suche nach neuestem Backup..."
        BACKUP_FILE=$(ls -t /var/www/html/voting-tool-backups/voting-db-backup-*.sql 2>/dev/null | head -1)
        echo "Gefundenes Backup: ${BACKUP_FILE}"
      fi
      
      # Pr√ºfe Backup-Datei
      if [ -f "${BACKUP_FILE}" ]; then
        echo "Stelle Backup wieder her: ${BACKUP_FILE}"
        
        # Docker Compose Status pr√ºfen
        echo "Docker Compose Status:"
        docker compose ps
        
        # Importiere Backup
        docker compose exec -T db mysql -u root -p${VOTING_DB_ROOT_PASSWORD:-root_password} ${VOTING_DB_NAME:-voting_db} < "${BACKUP_FILE}"
        
        if [ $? -eq 0 ]; then
          echo "‚úÖ Datenbank erfolgreich wiederhergestellt"
          
          # Pr√ºfe ob Testdaten entfernt wurden
          USER_COUNT=$(docker compose exec -T db mysql -u root -p${VOTING_DB_ROOT_PASSWORD:-root_password} ${VOTING_DB_NAME:-voting_db} -e "SELECT COUNT(*) FROM event_user WHERE event_id = (SELECT id FROM event WHERE slug = 'lasttest-2025');" -N 2>/dev/null || echo "0")
          echo "Verbleibende Testnutzer: ${USER_COUNT}"
        else
          echo "‚ùå Wiederherstellung fehlgeschlagen!"
          exit 1
        fi
      else
        echo "‚ùå Backup-Datei nicht gefunden: ${BACKUP_FILE}"
        echo "Verf√ºgbare Backups:"
        ls -la /var/www/html/voting-tool-backups/ || echo "Keine Backups gefunden"
        exit 1
      fi
  needs:
    - backup_database_server
  when: manual
  only:
    - main
  tags:
    - server