# GitLab CI/CD Pipeline für Voting Tool
# Automatisches Build und Deploy bei Push auf main Branch

stages:
  - build
  - deploy
  - test-prepare
  - test-execute
  - test-cleanup

variables:
  # Docker Registry
  REGISTRY: "registry.failx.de"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  # Image Tags
  API_IMAGE: "${REGISTRY}/voting-tool/api"
  CLIENT_IMAGE: "${REGISTRY}/voting-tool/client"
  # Deployment Path auf dem gleichen Server
  DEPLOY_PATH: "/var/www/html/voting-tool"
  DOMAIN: "voting.failx.de"

# Basis-Job-Konfiguration
.docker_job:
  image: docker:24-cli
  before_script:
    - docker info
  tags:
    - docker
    - deploy

# Build API Image
build_api:
  extends: .docker_job
  stage: build
  script:
    - echo "🔨 Building API image..."
    - docker build -f docker/production/Dockerfile.api -t ${API_IMAGE}:latest -t ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} .
    - |
      if docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${REGISTRY} 2>/dev/null; then
        docker push ${API_IMAGE}:latest || echo "⚠️ Push failed, continuing with local image"
        docker push ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Push failed, continuing with local image"
        echo "✅ API image build completed"
      else
        echo "⚠️  Registry not available, using local images"
      fi
  only:
    - main
    - merge_requests

# Build Client Image
build_client:
  extends: .docker_job
  stage: build
  script:
    - echo "🔨 Building Client image..."
    - |
      docker build -f docker/production/Dockerfile.client \
        --build-arg VITE_API_BASE_URL=https://${DOMAIN} \
        --build-arg VITE_SUBSCRIPTION_URL=wss://${DOMAIN}/graphql \
        --build-arg DOMAIN=${DOMAIN} \
        -t ${CLIENT_IMAGE}:latest \
        -t ${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA} .
    - |
      if docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${REGISTRY} 2>/dev/null; then
        docker push ${CLIENT_IMAGE}:latest || echo "⚠️ Push failed, continuing with local image"
        docker push ${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Push failed, continuing with local image"
        echo "✅ Client image build completed"
      else
        echo "⚠️  Registry not available, using local images"
      fi
  only:
    - main
    - merge_requests

# Deploy to Production (auf dem gleichen Server)
deploy:
  stage: deploy
  script:
    - echo "🚀 Deploying voting tool..."
    
    # Backup erstellen
    - |
      if [ -f "${DEPLOY_PATH}/docker-compose.yml" ]; then
        cp ${DEPLOY_PATH}/docker-compose.yml ${DEPLOY_PATH}/docker-compose.yml.backup.$(date +%Y%m%d_%H%M%S)
        echo "✅ Backup created"
      fi
      
      # Verzeichnis erstellen falls nicht vorhanden
      mkdir -p ${DEPLOY_PATH}
      
      # Docker-Compose und andere Dateien kopieren
      cp docker/production/docker-compose.yml ${DEPLOY_PATH}/
      
      # .env Datei erstellen mit den neuesten Image Tags
      # Check if registry images are available, otherwise use local images
      if docker pull ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} 2>/dev/null; then
        export API_IMAGE="${API_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        export CLIENT_IMAGE="${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        echo "✅ Using registry images with SHA tags"
      else
        # Tag local images with SHA for deployment
        docker tag ${API_IMAGE}:latest ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Failed to tag API image"
        docker tag ${CLIENT_IMAGE}:latest ${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Failed to tag Client image"
        export API_IMAGE="${API_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        export CLIENT_IMAGE="${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        echo "✅ Using locally tagged images with SHA"
      fi
      
      # Set environment variables for deployment
      export CI_COMMIT_SHORT_SHA="${CI_COMMIT_SHORT_SHA}"
      export DOMAIN="${DOMAIN}"
      export NODE_ENV="production"
      export DATABASE_HOST="db"
      export DATABASE_USER="${VOTING_DB_USER:-voting_user}"
      export DATABASE_PASSWORD="${VOTING_DB_PASSWORD:-voting_password}"
      export DATABASE_NAME="${VOTING_DB_NAME:-voting_db}"
      export DATABASE_ROOT_PASSWORD="${VOTING_DB_ROOT_PASSWORD:-root_password}"
      export JWT_SECRET="${VOTING_JWT_SECRET:-voting-jwt-secret-key}"
      export COOKIE_SIGN_SECRET="${VOTING_COOKIE_SIGN_SECRET:-voting-cookie-secret-key}"
      export EMAIL_HOST="${VOTING_EMAIL_HOST:-smtp.example.com}"
      export EMAIL_PORT="${VOTING_EMAIL_PORT:-587}"
      export EMAIL_USER="${VOTING_EMAIL_USER:-noreply@example.com}"
      export EMAIL_PASSWORD="${VOTING_EMAIL_PASSWORD:-email_password}"
      
      # Create clean .env file manually (avoid env parsing issues)
      cat > ${DEPLOY_PATH}/.env << 'ENVEOF'
      API_IMAGE=${API_IMAGE}
      CLIENT_IMAGE=${CLIENT_IMAGE}
      CI_COMMIT_SHORT_SHA=${CI_COMMIT_SHORT_SHA}
      DOMAIN=${DOMAIN}
      NODE_ENV=${NODE_ENV}
      DATABASE_HOST=${DATABASE_HOST}
      DATABASE_USER=${DATABASE_USER}
      DATABASE_PASSWORD=${DATABASE_PASSWORD}
      DATABASE_NAME=${DATABASE_NAME}
      DATABASE_ROOT_PASSWORD=${DATABASE_ROOT_PASSWORD}
      JWT_SECRET=${JWT_SECRET}
      COOKIE_SIGN_SECRET=${COOKIE_SIGN_SECRET}
      EMAIL_HOST=${EMAIL_HOST}
      EMAIL_PORT=${EMAIL_PORT}
      EMAIL_USER=${EMAIL_USER}
      EMAIL_PASSWORD=${EMAIL_PASSWORD}
      ENVEOF
      
      # Deploy mit docker-compose
      cd ${DEPLOY_PATH}
      docker compose pull || echo "⚠️ Pull failed, using local images"
      docker compose up -d --remove-orphans
      
      # Status anzeigen
      docker ps | grep voting
      echo "✅ Voting tool deployment completed"
  
  environment:
    name: production
    url: https://${DOMAIN}
  when: on_success
  only:
    - main
  needs:
    - build_api
    - build_client
  tags:
    - docker
    - deploy

# Deploy Vereinswahl Instance
deploy_vereinswahl:
  stage: deploy
  script:
    - echo "🚀 Deploying Vereinswahl Voting Tool..."
    
    # Variables
    - export VEREINSWAHL_DEPLOY_PATH="/var/www/html/voting-tool-vereinswahl"
    - export VEREINSWAHL_DOMAIN="vereinswahl.vielwerth-junginger.de"
    
    # Backup erstellen
    - |
      if [ -f "${VEREINSWAHL_DEPLOY_PATH}/docker-compose.yml" ]; then
        cp ${VEREINSWAHL_DEPLOY_PATH}/docker-compose.yml ${VEREINSWAHL_DEPLOY_PATH}/docker-compose.yml.backup.$(date +%Y%m%d_%H%M%S)
        echo "✅ Backup created"
      fi
      
      # Verzeichnis erstellen falls nicht vorhanden
      mkdir -p ${VEREINSWAHL_DEPLOY_PATH}
      
      # Docker-Compose kopieren
      cp docker/production/docker-compose-vereinswahl.yml ${VEREINSWAHL_DEPLOY_PATH}/docker-compose.yml
      
      # Check if registry images are available, otherwise use local images
      if docker pull ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} 2>/dev/null; then
        export API_IMAGE="${API_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        export CLIENT_IMAGE="${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        echo "✅ Using registry images with SHA tags"
      else
        # Tag local images with SHA for deployment
        docker tag ${API_IMAGE}:latest ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Failed to tag API image"
        docker tag ${CLIENT_IMAGE}:latest ${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Failed to tag Client image"
        export API_IMAGE="${API_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        export CLIENT_IMAGE="${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        echo "✅ Using locally tagged images with SHA"
      fi
      
      # Set environment variables for deployment
      export CI_COMMIT_SHORT_SHA="${CI_COMMIT_SHORT_SHA}"
      export DOMAIN="${VEREINSWAHL_DOMAIN}"
      export NODE_ENV="production"
      export DATABASE_HOST="db"
      export DATABASE_USER="${VEREINSWAHL_DB_USER:-vereinswahl_user}"
      export DATABASE_PASSWORD="${VEREINSWAHL_DB_PASSWORD:-vereinswahl_password}"
      export DATABASE_NAME="${VEREINSWAHL_DB_NAME:-vereinswahl_db}"
      export DATABASE_ROOT_PASSWORD="${VEREINSWAHL_DB_ROOT_PASSWORD:-vereinswahl_root_password}"
      export JWT_SECRET="${VEREINSWAHL_JWT_SECRET:-vereinswahl-jwt-secret-key}"
      export COOKIE_SIGN_SECRET="${VEREINSWAHL_COOKIE_SIGN_SECRET:-vereinswahl-cookie-secret-key}"
      export EMAIL_HOST="${VEREINSWAHL_EMAIL_HOST:-smtp.example.com}"
      export EMAIL_PORT="${VEREINSWAHL_EMAIL_PORT:-587}"
      export EMAIL_USER="${VEREINSWAHL_EMAIL_USER:-noreply@vielwerth-junginger.de}"
      export EMAIL_PASSWORD="${VEREINSWAHL_EMAIL_PASSWORD:-email_password}"
      
      # Create clean .env file manually (avoid env parsing issues)
      cat > ${VEREINSWAHL_DEPLOY_PATH}/.env << 'ENVEOF'
      API_IMAGE=${API_IMAGE}
      CLIENT_IMAGE=${CLIENT_IMAGE}
      CI_COMMIT_SHORT_SHA=${CI_COMMIT_SHORT_SHA}
      DOMAIN=${DOMAIN}
      NODE_ENV=${NODE_ENV}
      DATABASE_HOST=${DATABASE_HOST}
      DATABASE_USER=${DATABASE_USER}
      DATABASE_PASSWORD=${DATABASE_PASSWORD}
      DATABASE_NAME=${DATABASE_NAME}
      DATABASE_ROOT_PASSWORD=${DATABASE_ROOT_PASSWORD}
      JWT_SECRET=${JWT_SECRET}
      COOKIE_SIGN_SECRET=${COOKIE_SIGN_SECRET}
      EMAIL_HOST=${EMAIL_HOST}
      EMAIL_PORT=${EMAIL_PORT}
      EMAIL_USER=${EMAIL_USER}
      EMAIL_PASSWORD=${EMAIL_PASSWORD}
      ENVEOF
      
      # Deploy mit docker-compose
      cd ${VEREINSWAHL_DEPLOY_PATH}
      docker compose pull || echo "⚠️ Pull failed, using local images"
      docker compose up -d --remove-orphans
      
      # Status anzeigen
      docker ps | grep vereinswahl
      echo "✅ Vereinswahl voting tool deployment completed"
  
  environment:
    name: vereinswahl-production
    url: https://${VEREINSWAHL_DOMAIN}
  when: manual
  only:
    - main
  needs:
    - build_api
    - build_client
  tags:
    - docker
    - deploy

# Rollback Job
rollback:
  stage: deploy
  script:
    - echo "⏪ Rolling back voting tool..."
    
    # Find latest backup
    - |
      cd ${DEPLOY_PATH}
      latest_backup=$(ls -t docker-compose.yml.backup.* 2>/dev/null | head -1)
      
      if [ -n "$latest_backup" ]; then
        echo "Found backup: $latest_backup"
        cp $latest_backup docker-compose.yml
        docker compose up -d --remove-orphans
        echo "✅ Rollback completed"
      else
        echo "❌ No backup found!"
        exit 1
      fi
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy

# ============================================
# TEST STAGE JOBS - Manuell triggerbare Tests
# ============================================

# Datenbank Backup erstellen
backup_database:
  stage: test-prepare
  script:
    - echo "📦 Erstelle Datenbank-Backup..."
    - |
      # Variablen für Test-Umgebung
      export TEST_DEPLOY_PATH="/var/www/html/voting-tool"
      export BACKUP_DIR="/var/www/html/voting-tool-backups"
      
      # Backup-Verzeichnis erstellen
      mkdir -p ${BACKUP_DIR}
      
      # Timestamp für Backup
      export BACKUP_TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      export BACKUP_FILE="${BACKUP_DIR}/voting-db-backup-${BACKUP_TIMESTAMP}.sql"
      
      # Datenbank-Backup erstellen
      cd ${TEST_DEPLOY_PATH}
      docker compose exec -T db mysqldump -u root -p${DATABASE_ROOT_PASSWORD} ${DATABASE_NAME} > ${BACKUP_FILE}
      
      # Prüfe Backup-Größe
      if [ -s ${BACKUP_FILE} ]; then
        echo "✅ Backup erfolgreich erstellt: ${BACKUP_FILE}"
        echo "Backup-Größe: $(du -h ${BACKUP_FILE} | cut -f1)"
        
        # Speichere Backup-Pfad für spätere Jobs
        echo "BACKUP_FILE=${BACKUP_FILE}" > backup-info.env
        echo "BACKUP_TIMESTAMP=${BACKUP_TIMESTAMP}" >> backup-info.env
      else
        echo "❌ Backup fehlgeschlagen - Datei ist leer!"
        exit 1
      fi
  artifacts:
    reports:
      dotenv: backup-info.env
    expire_in: 1 week
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy

# Testdaten importieren
import_test_data:
  stage: test-prepare
  script:
    - echo "📥 Importiere Testdaten..."
    - |
      export TEST_DEPLOY_PATH="/var/www/html/voting-tool"
      
      # Kopiere SQL-Datei zum Server
      cp test-data/load-test-scenario.sql ${TEST_DEPLOY_PATH}/
      
      cd ${TEST_DEPLOY_PATH}
      
      # Importiere Testdaten
      docker compose exec -T db mysql -u root -p${DATABASE_ROOT_PASSWORD} ${DATABASE_NAME} < load-test-scenario.sql
      
      if [ $? -eq 0 ]; then
        echo "✅ Testdaten erfolgreich importiert"
        
        # Aufräumen
        rm -f load-test-scenario.sql
        
        # Speichere Event-Informationen
        echo "TEST_EVENT_SLUG=lasttest-2025" > test-info.env
        echo "TEST_EVENT_URL=https://${DOMAIN}/#/register/lasttest-2025" >> test-info.env
      else
        echo "❌ Import der Testdaten fehlgeschlagen!"
        exit 1
      fi
  artifacts:
    reports:
      dotenv: test-info.env
    expire_in: 1 week
  needs:
    - backup_database
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy

# Playwright Load Tests ausführen (Ressourcen-optimiert)
run_load_tests:
  stage: test-execute
  image: mcr.microsoft.com/playwright:v1.40.0-jammy
  variables:
    # Ressourcen-Limits für Container
    NODE_OPTIONS: "--max-old-space-size=2048"
    PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "0"
  script:
    - echo "🎭 Führe Playwright Load Tests aus (Pipeline-optimiert)..."
    - |
      cd voting-tool/voting-service-client-v2
      
      # System-Info
      echo "System-Ressourcen:"
      free -h
      nproc
      
      # Installiere Dependencies
      npm ci
      
      # Installiere nur Chromium
      npx playwright install chromium
      npx playwright install-deps chromium
      
      # Setze Test-Umgebungsvariablen
      export TEST_BASE_URL="https://${DOMAIN}"
      export TEST_EVENT_SLUG="${TEST_EVENT_SLUG}"
      export MAX_BROWSERS=3  # Limitiere gleichzeitige Browser
      
      # Verwende Pipeline-optimierte Config
      echo "Kopiere Pipeline-Config..."
      cp tests/lib/config-pipeline.js tests/lib/config.js
      
      # Führe Load Tests mit Pipeline-Config aus
      echo "Starte Load Test mit 20 Nutzern (Pipeline-optimiert)..."
      npx playwright test tests/load-test/load-test.spec.js \
        --config=playwright-pipeline.config.js \
        --workers=1 \
        --retries=1
      
      # Sammle Ergebnisse
      if [ -d "voting-results" ]; then
        echo "✅ Test-Ergebnisse gefunden"
        ls -la voting-results/
      fi
      
      # Generiere Reports
      node tests/lib/resultFormatter.js || true
  artifacts:
    when: always
    paths:
      - voting-tool/voting-service-client-v2/voting-results/
      - voting-tool/voting-service-client-v2/test-results/
      - voting-tool/voting-service-client-v2/playwright-report/
    reports:
      junit: voting-tool/voting-service-client-v2/test-results/junit.xml
    expire_in: 1 week
  needs:
    - import_test_data
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy

# Performance Test ausführen
run_performance_test:
  stage: test-execute
  image: mcr.microsoft.com/playwright:v1.40.0-jammy
  script:
    - echo "⚡ Führe Performance Tests aus..."
    - |
      cd voting-tool/voting-service-client-v2
      
      # Installiere Dependencies
      npm ci
      
      # Setze Test-Umgebungsvariablen
      export TEST_BASE_URL="https://${DOMAIN}"
      export TEST_EVENT_SLUG="${TEST_EVENT_SLUG}"
      export TEST_MODE="performance"
      
      # Erstelle neuen Performance-Test wenn noch nicht vorhanden
      if [ ! -f "tests/performance/performance-test.spec.js" ]; then
        mkdir -p tests/performance
        # Kopiere und modifiziere den Load-Test für Performance-Messungen
        cp tests/load-test/load-test.spec.js tests/performance/performance-test.spec.js
      fi
      
      # Führe Performance Tests aus
      npx playwright test tests/performance/ --reporter=html
  artifacts:
    when: always
    paths:
      - voting-tool/voting-service-client-v2/voting-results/
      - voting-tool/voting-service-client-v2/playwright-report/
    expire_in: 1 week
  needs:
    - import_test_data
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy

# Datenbank wiederherstellen
restore_database:
  stage: test-cleanup
  script:
    - echo "♻️ Stelle Datenbank-Backup wieder her..."
    - |
      export TEST_DEPLOY_PATH="/var/www/html/voting-tool"
      
      cd ${TEST_DEPLOY_PATH}
      
      # Prüfe ob Backup-Datei existiert
      if [ -f "${BACKUP_FILE}" ]; then
        echo "Stelle Backup wieder her: ${BACKUP_FILE}"
        
        # Importiere Backup
        docker compose exec -T db mysql -u root -p${DATABASE_ROOT_PASSWORD} ${DATABASE_NAME} < ${BACKUP_FILE}
        
        if [ $? -eq 0 ]; then
          echo "✅ Datenbank erfolgreich wiederhergestellt"
          
          # Optional: Backup-Datei behalten für Archivierung
          echo "Backup-Datei bleibt erhalten: ${BACKUP_FILE}"
        else
          echo "❌ Wiederherstellung fehlgeschlagen!"
          exit 1
        fi
      else
        echo "❌ Backup-Datei nicht gefunden: ${BACKUP_FILE}"
        exit 1
      fi
  needs:
    - backup_database
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy