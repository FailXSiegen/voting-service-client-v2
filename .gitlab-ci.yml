# GitLab CI/CD Pipeline für Voting Tool
# Automatisches Build und Deploy bei Push auf main Branch

stages:
  - build
  - deploy
  - test-prepare
  - test-execute
  - test-cleanup

variables:
  # Docker Registry
  REGISTRY: "registry.failx.de"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  # Image Tags
  API_IMAGE: "${REGISTRY}/voting-tool/api"
  CLIENT_IMAGE: "${REGISTRY}/voting-tool/client"
  # Deployment Path auf dem gleichen Server
  DEPLOY_PATH: "/var/www/html/voting-tool"
  DOMAIN: "voting.failx.de"

# Basis-Job-Konfiguration
.docker_job:
  image: docker:24-cli
  before_script:
    - docker info
  tags:
    - docker
    - deploy

# Build API Image
build_api:
  extends: .docker_job
  stage: build
  script:
    - echo "🔨 Building API image..."
    - docker build -f docker/production/Dockerfile.api -t ${API_IMAGE}:latest -t ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} .
    - |
      if docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${REGISTRY} 2>/dev/null; then
        docker push ${API_IMAGE}:latest || echo "⚠️ Push failed, continuing with local image"
        docker push ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Push failed, continuing with local image"
        echo "✅ API image build completed"
      else
        echo "⚠️  Registry not available, using local images"
      fi
  only:
    - main
    - merge_requests

# Build Client Image
build_client:
  extends: .docker_job
  stage: build
  script:
    - echo "🔨 Building Client image..."
    - |
      docker build -f docker/production/Dockerfile.client \
        --build-arg VITE_API_BASE_URL=https://${DOMAIN} \
        --build-arg VITE_SUBSCRIPTION_URL=wss://${DOMAIN}/graphql \
        --build-arg DOMAIN=${DOMAIN} \
        -t ${CLIENT_IMAGE}:latest \
        -t ${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA} .
    - |
      if docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${REGISTRY} 2>/dev/null; then
        docker push ${CLIENT_IMAGE}:latest || echo "⚠️ Push failed, continuing with local image"
        docker push ${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Push failed, continuing with local image"
        echo "✅ Client image build completed"
      else
        echo "⚠️  Registry not available, using local images"
      fi
  only:
    - main
    - merge_requests

# Deploy to Production (auf dem gleichen Server)
deploy:
  stage: deploy
  script:
    - echo "🚀 Deploying voting tool..."
    
    # Backup erstellen
    - |
      if [ -f "${DEPLOY_PATH}/docker-compose.yml" ]; then
        cp ${DEPLOY_PATH}/docker-compose.yml ${DEPLOY_PATH}/docker-compose.yml.backup.$(date +%Y%m%d_%H%M%S)
        echo "✅ Backup created"
      fi
      
      # Verzeichnis erstellen falls nicht vorhanden
      mkdir -p ${DEPLOY_PATH}
      
      # Docker-Compose und andere Dateien kopieren
      cp docker/production/docker-compose.yml ${DEPLOY_PATH}/
      
      # .env Datei erstellen mit den neuesten Image Tags
      # Check if registry images are available, otherwise use local images
      if docker pull ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} 2>/dev/null; then
        export API_IMAGE="${API_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        export CLIENT_IMAGE="${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        echo "✅ Using registry images with SHA tags"
      else
        # Tag local images with SHA for deployment
        docker tag ${API_IMAGE}:latest ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Failed to tag API image"
        docker tag ${CLIENT_IMAGE}:latest ${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Failed to tag Client image"
        export API_IMAGE="${API_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        export CLIENT_IMAGE="${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        echo "✅ Using locally tagged images with SHA"
      fi
      
      # Set environment variables for deployment
      export CI_COMMIT_SHORT_SHA="${CI_COMMIT_SHORT_SHA}"
      export DOMAIN="${DOMAIN}"
      export NODE_ENV="production"
      export DATABASE_HOST="db"
      export DATABASE_USER="${VOTING_DB_USER:-voting_user}"
      export DATABASE_PASSWORD="${VOTING_DB_PASSWORD:-voting_password}"
      export DATABASE_NAME="${VOTING_DB_NAME:-voting_db}"
      export DATABASE_ROOT_PASSWORD="${VOTING_DB_ROOT_PASSWORD:-root_password}"
      export JWT_SECRET="${VOTING_JWT_SECRET:-voting-jwt-secret-key}"
      export COOKIE_SIGN_SECRET="${VOTING_COOKIE_SIGN_SECRET:-voting-cookie-secret-key}"
      export EMAIL_HOST="${VOTING_EMAIL_HOST:-smtp.example.com}"
      export EMAIL_PORT="${VOTING_EMAIL_PORT:-587}"
      export EMAIL_USER="${VOTING_EMAIL_USER:-noreply@example.com}"
      export EMAIL_PASSWORD="${VOTING_EMAIL_PASSWORD:-email_password}"
      
      # Create clean .env file manually (avoid env parsing issues)
      cat > ${DEPLOY_PATH}/.env << 'ENVEOF'
      API_IMAGE=${API_IMAGE}
      CLIENT_IMAGE=${CLIENT_IMAGE}
      CI_COMMIT_SHORT_SHA=${CI_COMMIT_SHORT_SHA}
      DOMAIN=${DOMAIN}
      NODE_ENV=${NODE_ENV}
      DATABASE_HOST=${DATABASE_HOST}
      DATABASE_USER=${DATABASE_USER}
      DATABASE_PASSWORD=${DATABASE_PASSWORD}
      DATABASE_NAME=${DATABASE_NAME}
      DATABASE_ROOT_PASSWORD=${DATABASE_ROOT_PASSWORD}
      JWT_SECRET=${JWT_SECRET}
      COOKIE_SIGN_SECRET=${COOKIE_SIGN_SECRET}
      EMAIL_HOST=${EMAIL_HOST}
      EMAIL_PORT=${EMAIL_PORT}
      EMAIL_USER=${EMAIL_USER}
      EMAIL_PASSWORD=${EMAIL_PASSWORD}
      ENVEOF
      
      # Deploy mit docker-compose
      cd ${DEPLOY_PATH}
      docker compose pull || echo "⚠️ Pull failed, using local images"
      docker compose up -d --remove-orphans
      
      # Status anzeigen
      docker ps | grep voting
      echo "✅ Voting tool deployment completed"
  
  environment:
    name: production
    url: https://${DOMAIN}
  when: on_success
  only:
    - main
  needs:
    - build_api
    - build_client
  tags:
    - docker
    - deploy

# Deploy Vereinswahl Instance
deploy_vereinswahl:
  stage: deploy
  script:
    - echo "🚀 Deploying Vereinswahl Voting Tool..."
    
    # Variables
    - export VEREINSWAHL_DEPLOY_PATH="/var/www/html/voting-tool-vereinswahl"
    - export VEREINSWAHL_DOMAIN="vereinswahl.vielwerth-junginger.de"
    
    # Backup erstellen
    - |
      if [ -f "${VEREINSWAHL_DEPLOY_PATH}/docker-compose.yml" ]; then
        cp ${VEREINSWAHL_DEPLOY_PATH}/docker-compose.yml ${VEREINSWAHL_DEPLOY_PATH}/docker-compose.yml.backup.$(date +%Y%m%d_%H%M%S)
        echo "✅ Backup created"
      fi
      
      # Verzeichnis erstellen falls nicht vorhanden
      mkdir -p ${VEREINSWAHL_DEPLOY_PATH}
      
      # Docker-Compose kopieren
      cp docker/production/docker-compose-vereinswahl.yml ${VEREINSWAHL_DEPLOY_PATH}/docker-compose.yml
      
      # Check if registry images are available, otherwise use local images
      if docker pull ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} 2>/dev/null; then
        export API_IMAGE="${API_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        export CLIENT_IMAGE="${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        echo "✅ Using registry images with SHA tags"
      else
        # Tag local images with SHA for deployment
        docker tag ${API_IMAGE}:latest ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Failed to tag API image"
        docker tag ${CLIENT_IMAGE}:latest ${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "⚠️ Failed to tag Client image"
        export API_IMAGE="${API_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        export CLIENT_IMAGE="${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        echo "✅ Using locally tagged images with SHA"
      fi
      
      # Set environment variables for deployment
      export CI_COMMIT_SHORT_SHA="${CI_COMMIT_SHORT_SHA}"
      export DOMAIN="${VEREINSWAHL_DOMAIN}"
      export NODE_ENV="production"
      export DATABASE_HOST="db"
      export DATABASE_USER="${VEREINSWAHL_DB_USER:-vereinswahl_user}"
      export DATABASE_PASSWORD="${VEREINSWAHL_DB_PASSWORD:-vereinswahl_password}"
      export DATABASE_NAME="${VEREINSWAHL_DB_NAME:-vereinswahl_db}"
      export DATABASE_ROOT_PASSWORD="${VEREINSWAHL_DB_ROOT_PASSWORD:-vereinswahl_root_password}"
      export JWT_SECRET="${VEREINSWAHL_JWT_SECRET:-vereinswahl-jwt-secret-key}"
      export COOKIE_SIGN_SECRET="${VEREINSWAHL_COOKIE_SIGN_SECRET:-vereinswahl-cookie-secret-key}"
      export EMAIL_HOST="${VEREINSWAHL_EMAIL_HOST:-smtp.example.com}"
      export EMAIL_PORT="${VEREINSWAHL_EMAIL_PORT:-587}"
      export EMAIL_USER="${VEREINSWAHL_EMAIL_USER:-noreply@vielwerth-junginger.de}"
      export EMAIL_PASSWORD="${VEREINSWAHL_EMAIL_PASSWORD:-email_password}"
      
      # Create clean .env file manually (avoid env parsing issues)
      cat > ${VEREINSWAHL_DEPLOY_PATH}/.env << 'ENVEOF'
      API_IMAGE=${API_IMAGE}
      CLIENT_IMAGE=${CLIENT_IMAGE}
      CI_COMMIT_SHORT_SHA=${CI_COMMIT_SHORT_SHA}
      DOMAIN=${DOMAIN}
      NODE_ENV=${NODE_ENV}
      DATABASE_HOST=${DATABASE_HOST}
      DATABASE_USER=${DATABASE_USER}
      DATABASE_PASSWORD=${DATABASE_PASSWORD}
      DATABASE_NAME=${DATABASE_NAME}
      DATABASE_ROOT_PASSWORD=${DATABASE_ROOT_PASSWORD}
      JWT_SECRET=${JWT_SECRET}
      COOKIE_SIGN_SECRET=${COOKIE_SIGN_SECRET}
      EMAIL_HOST=${EMAIL_HOST}
      EMAIL_PORT=${EMAIL_PORT}
      EMAIL_USER=${EMAIL_USER}
      EMAIL_PASSWORD=${EMAIL_PASSWORD}
      ENVEOF
      
      # Deploy mit docker-compose
      cd ${VEREINSWAHL_DEPLOY_PATH}
      docker compose pull || echo "⚠️ Pull failed, using local images"
      docker compose up -d --remove-orphans
      
      # Status anzeigen
      docker ps | grep vereinswahl
      echo "✅ Vereinswahl voting tool deployment completed"
  
  environment:
    name: vereinswahl-production
    url: https://${VEREINSWAHL_DOMAIN}
  when: manual
  only:
    - main
  needs:
    - build_api
    - build_client
  tags:
    - docker
    - deploy

# Rollback Job
rollback:
  stage: deploy
  script:
    - echo "⏪ Rolling back voting tool..."
    
    # Find latest backup
    - |
      cd ${DEPLOY_PATH}
      latest_backup=$(ls -t docker-compose.yml.backup.* 2>/dev/null | head -1)
      
      if [ -n "$latest_backup" ]; then
        echo "Found backup: $latest_backup"
        cp $latest_backup docker-compose.yml
        docker compose up -d --remove-orphans
        echo "✅ Rollback completed"
      else
        echo "❌ No backup found!"
        exit 1
      fi
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy

# ============================================
# SERVER RUNNER JOBS (wenn verfügbar)
# ============================================

# Include Server-Runner Jobs falls verfügbar
include:
  - local: '.gitlab-ci-server-runner.yml'

# ============================================
# TEST STAGE JOBS - Manuell triggerbare Tests
# ============================================

# Datenbank Backup erstellen (mit temporärem Container)
backup_database:
  stage: test-prepare
  script:
    - echo "📦 Erstelle Datenbank-Backup mit temporärem Container..."
    - |
      # Erstelle temporäres Volume für Backups
      docker volume create voting-test-backups || true
      
      # Timestamp für Backup
      export BACKUP_TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      export BACKUP_FILENAME="voting-db-backup-${BACKUP_TIMESTAMP}.sql"
      
      # Finde das voting-tool DB Network
      VOTING_NETWORK=$(docker network ls --format "table {{.Name}}" | grep voting-tool | head -1)
      if [ -z "$VOTING_NETWORK" ]; then
        # Fallback: versuche häufige Namen
        VOTING_NETWORK="voting-tool_default"
        echo "Verwende Standard-Netzwerk: $VOTING_NETWORK"
      else
        echo "Gefundenes Netzwerk: $VOTING_NETWORK"
      fi
      
      # Starte temporären MySQL-Client Container für Backup
      echo "Erstelle Backup über temporären Container..."
      docker run --rm \
        --network ${VOTING_NETWORK} \
        -v voting-test-backups:/backups \
        mysql:8.0 \
        sh -c "
          mysqldump -h db -u root -p${VOTING_DB_ROOT_PASSWORD:-root_password} ${VOTING_DB_NAME:-voting_db} > /backups/${BACKUP_FILENAME} 2>/dev/null
          if [ -s /backups/${BACKUP_FILENAME} ]; then
            echo 'Backup erfolgreich erstellt: ${BACKUP_FILENAME}'
            ls -lah /backups/${BACKUP_FILENAME}
            exit 0
          else
            echo 'Backup fehlgeschlagen!'
            exit 1
          fi
        "
      
      if [ $? -eq 0 ]; then
        # Speichere Backup-Info für spätere Jobs
        echo "BACKUP_FILENAME=${BACKUP_FILENAME}" > backup-info.env
        echo "BACKUP_TIMESTAMP=${BACKUP_TIMESTAMP}" >> backup-info.env
        echo "BACKUP_VOLUME=voting-test-backups" >> backup-info.env
        echo "✅ Backup-Container erfolgreich ausgeführt"
      else
        echo "❌ Backup-Container fehlgeschlagen!"
        exit 1
      fi
  artifacts:
    reports:
      dotenv: backup-info.env
    expire_in: 1 week
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy

# Testdaten importieren (mit temporärem Container)
import_test_data:
  stage: test-prepare
  script:
    - echo "📥 Importiere Testdaten mit temporärem Container..."
    - |
      # Finde das voting-tool DB Network
      VOTING_NETWORK=$(docker network ls --format "table {{.Name}}" | grep voting-tool | head -1)
      if [ -z "$VOTING_NETWORK" ]; then
        VOTING_NETWORK="voting-tool_default"
        echo "Verwende Standard-Netzwerk: $VOTING_NETWORK"
      else
        echo "Gefundenes Netzwerk: $VOTING_NETWORK"
      fi
      
      # Erstelle temporäres Volume für SQL-Datei
      docker volume create voting-test-sql || true
      
      # Kopiere SQL-Datei in Volume über temporären Container
      echo "Kopiere SQL-Datei in temporären Container..."
      echo "Current directory: $(pwd)"
      echo "Available files:"
      ls -la test-data/ || echo "test-data directory not found"
      
      # Debug: Prüfe aktuelles Verzeichnis und Inhalt
      if [ ! -f "test-data/load-test-scenario.sql" ]; then
        echo "❌ SQL-Datei nicht gefunden!"
        echo "Working directory: $(pwd)"
        echo "Directory contents:"
        find . -name "*.sql" -type f 2>/dev/null || echo "Keine SQL-Dateien gefunden"
        exit 1
      fi
      
      docker run --rm \
        -v "$(pwd)/test-data:/source:ro" \
        -v voting-test-sql:/sql \
        alpine:latest \
        sh -c "ls -la /source/ && cp /source/load-test-scenario.sql /sql/ && echo 'SQL-Datei erfolgreich kopiert'"
      
      # Importiere Testdaten über temporären MySQL-Client
      echo "Importiere SQL-Daten über temporären Container..."
      docker run --rm \
        --network ${VOTING_NETWORK} \
        -v voting-test-sql:/sql \
        mysql:8.0 \
        sh -c "
          echo 'Verbinde zur Datenbank...'
          mysql -h db -u root -p${VOTING_DB_ROOT_PASSWORD:-root_password} ${VOTING_DB_NAME:-voting_db} < /sql/load-test-scenario.sql
          
          if [ \$? -eq 0 ]; then
            echo 'Import erfolgreich!'
            
            # Prüfe importierte Daten
            USER_COUNT=\$(mysql -h db -u root -p${VOTING_DB_ROOT_PASSWORD:-root_password} ${VOTING_DB_NAME:-voting_db} -e \"SELECT COUNT(*) FROM event_user WHERE event_id = (SELECT id FROM event WHERE slug = 'lasttest-2025');\" -N 2>/dev/null)
            echo \"Importierte Testnutzer: \$USER_COUNT\"
            echo \$USER_COUNT > /sql/user_count.txt
            exit 0
          else
            echo 'Import fehlgeschlagen!'
            exit 1
          fi
        "
      
      if [ $? -eq 0 ]; then
        # Lese User-Count aus Container
        USER_COUNT=$(docker run --rm -v voting-test-sql:/sql alpine:latest cat /sql/user_count.txt 2>/dev/null || echo "0")
        
        echo "✅ Testdaten erfolgreich importiert: ${USER_COUNT} Nutzer"
        
        # Speichere Event-Informationen
        echo "TEST_EVENT_SLUG=lasttest-2025" > test-info.env
        echo "TEST_EVENT_URL=https://${VOTING_DOMAIN:-voting.failx.de}/#/register/lasttest-2025" >> test-info.env
        echo "TEST_USER_COUNT=${USER_COUNT}" >> test-info.env
        
        # Cleanup temporäres Volume
        docker volume rm voting-test-sql || true
      else
        echo "❌ Import der Testdaten fehlgeschlagen!"
        docker volume rm voting-test-sql || true
        exit 1
      fi
  artifacts:
    reports:
      dotenv: test-info.env
    expire_in: 1 week
  needs:
    - backup_database
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy

# Playwright Load Tests ausführen (Ressourcen-optimiert)
run_load_tests:
  stage: test-execute
  image: mcr.microsoft.com/playwright:v1.40.0-jammy
  variables:
    # Ressourcen-Limits für Container
    NODE_OPTIONS: "--max-old-space-size=2048"
    PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "0"
  script:
    - echo "🎭 Führe Playwright Load Tests aus (Pipeline-optimiert)..."
    - |
      cd voting-tool/voting-service-client-v2
      
      # System-Info
      echo "System-Ressourcen:"
      free -h
      nproc
      
      # Installiere Dependencies
      npm ci
      
      # Installiere nur Chromium
      npx playwright install chromium
      npx playwright install-deps chromium
      
      # Setze Test-Umgebungsvariablen
      export TEST_BASE_URL="https://${DOMAIN}"
      export TEST_EVENT_SLUG="${TEST_EVENT_SLUG}"
      export MAX_BROWSERS=3  # Limitiere gleichzeitige Browser
      
      # Verwende Pipeline-optimierte Config
      echo "Kopiere Pipeline-Config..."
      cp tests/lib/config-pipeline.js tests/lib/config.js
      
      # Führe Load Tests mit Pipeline-Config aus
      echo "Starte Load Test mit 20 Nutzern (Pipeline-optimiert)..."
      npx playwright test tests/load-test/load-test.spec.js \
        --config=playwright-pipeline.config.js \
        --workers=1 \
        --retries=1
      
      # Sammle Ergebnisse
      if [ -d "voting-results" ]; then
        echo "✅ Test-Ergebnisse gefunden"
        ls -la voting-results/
      fi
      
      # Generiere Reports
      node tests/lib/resultFormatter.js || true
  artifacts:
    when: always
    paths:
      - voting-tool/voting-service-client-v2/voting-results/
      - voting-tool/voting-service-client-v2/test-results/
      - voting-tool/voting-service-client-v2/playwright-report/
    reports:
      junit: voting-tool/voting-service-client-v2/test-results/junit.xml
    expire_in: 1 week
  needs:
    - import_test_data
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy

# Performance Test ausführen
run_performance_test:
  stage: test-execute
  image: mcr.microsoft.com/playwright:v1.40.0-jammy
  script:
    - echo "⚡ Führe Performance Tests aus..."
    - |
      cd voting-tool/voting-service-client-v2
      
      # Installiere Dependencies
      npm ci
      
      # Setze Test-Umgebungsvariablen
      export TEST_BASE_URL="https://${DOMAIN}"
      export TEST_EVENT_SLUG="${TEST_EVENT_SLUG}"
      export TEST_MODE="performance"
      
      # Erstelle neuen Performance-Test wenn noch nicht vorhanden
      if [ ! -f "tests/performance/performance-test.spec.js" ]; then
        mkdir -p tests/performance
        # Kopiere und modifiziere den Load-Test für Performance-Messungen
        cp tests/load-test/load-test.spec.js tests/performance/performance-test.spec.js
      fi
      
      # Führe Performance Tests aus
      npx playwright test tests/performance/ --reporter=html
  artifacts:
    when: always
    paths:
      - voting-tool/voting-service-client-v2/voting-results/
      - voting-tool/voting-service-client-v2/playwright-report/
    expire_in: 1 week
  needs:
    - import_test_data
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy

# Datenbank wiederherstellen (mit temporärem Container)
restore_database:
  stage: test-cleanup
  script:
    - echo "♻️ Stelle Datenbank-Backup wieder her..."
    - |
      # Prüfe ob Backup-Volume existiert
      if ! docker volume ls | grep -q "voting-test-backups"; then
        echo "❌ FEHLER: Backup-Volume 'voting-test-backups' nicht gefunden!"
        echo "Verfügbare Volumes:"
        docker volume ls | grep voting
        exit 1
      fi
      
      # Finde das voting-tool DB Network  
      VOTING_NETWORK=$(docker network ls --format "table {{.Name}}" | grep voting-tool | head -1)
      if [ -z "$VOTING_NETWORK" ]; then
        VOTING_NETWORK="voting-tool_default"
        echo "Verwende Standard-Netzwerk: $VOTING_NETWORK"
      else
        echo "Gefundenes Netzwerk: $VOTING_NETWORK"
      fi
      
      # Verwende Backup-Filename aus backup_database Job oder suche neuestes
      if [ -z "${BACKUP_FILENAME}" ]; then
        echo "Suche nach neuestem Backup im Volume..."
        BACKUP_FILENAME=$(docker run --rm -v voting-test-backups:/backups alpine:latest \
          sh -c "ls -t /backups/voting-db-backup-*.sql 2>/dev/null | head -1 | xargs basename" || echo "")
        
        if [ -z "$BACKUP_FILENAME" ]; then
          echo "❌ Keine Backup-Datei gefunden!"
          docker run --rm -v voting-test-backups:/backups alpine:latest ls -la /backups/
          exit 1
        fi
        echo "Gefundenes Backup: ${BACKUP_FILENAME}"
      fi
      
      # Stelle Backup wieder her über temporären Container
      echo "Stelle Backup wieder her: ${BACKUP_FILENAME}"
      docker run --rm \
        --network ${VOTING_NETWORK} \
        -v voting-test-backups:/backups \
        mysql:8.0 \
        sh -c "
          if [ -f /backups/${BACKUP_FILENAME} ]; then
            echo 'Importiere Backup...'
            mysql -h db -u root -p${VOTING_DB_ROOT_PASSWORD:-root_password} ${VOTING_DB_NAME:-voting_db} < /backups/${BACKUP_FILENAME}
            
            if [ \$? -eq 0 ]; then
              echo 'Backup erfolgreich wiederhergestellt!'
              
              # Prüfe ob Testdaten entfernt wurden
              USER_COUNT=\$(mysql -h db -u root -p${VOTING_DB_ROOT_PASSWORD:-root_password} ${VOTING_DB_NAME:-voting_db} -e \"SELECT COUNT(*) FROM event_user WHERE event_id = (SELECT id FROM event WHERE slug = 'lasttest-2025');\" -N 2>/dev/null || echo '0')
              echo \"Verbleibende Testnutzer: \$USER_COUNT\"
              
              exit 0
            else
              echo 'Wiederherstellung fehlgeschlagen!'
              exit 1
            fi
          else
            echo 'Backup-Datei nicht gefunden: ${BACKUP_FILENAME}'
            ls -la /backups/
            exit 1
          fi
        "
      
      if [ $? -eq 0 ]; then
        echo "✅ Datenbank erfolgreich wiederhergestellt"
        echo "Backup-Volume bleibt für weitere Wiederherstellungen erhalten"
      else
        echo "❌ Wiederherstellung fehlgeschlagen!"
        exit 1
      fi
  needs:
    - backup_database
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy