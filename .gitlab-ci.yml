# GitLab CI/CD Pipeline f√ºr Voting Tool
# Automatisches Build und Deploy bei Push auf main Branch

stages:
  - build
  - deploy

variables:
  # Docker Registry
  REGISTRY: "registry.failx.de"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  # Image Tags
  API_IMAGE: "${REGISTRY}/voting-tool/api"
  CLIENT_IMAGE: "${REGISTRY}/voting-tool/client"
  # Deployment Path auf dem gleichen Server
  DEPLOY_PATH: "/var/www/html/voting-tool"
  DOMAIN: "voting.failx.de"

# Basis-Job-Konfiguration
.docker_job:
  image: docker:24-cli
  before_script:
    - docker info
  tags:
    - docker
    - deploy

# Build API Image
build_api:
  extends: .docker_job
  stage: build
  script:
    - echo "üî® Building API image..."
    - docker build -f docker/production/Dockerfile.api -t ${API_IMAGE}:latest -t ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} .
    - |
      if docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${REGISTRY} 2>/dev/null; then
        docker push ${API_IMAGE}:latest || echo "‚ö†Ô∏è Push failed, continuing with local image"
        docker push ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "‚ö†Ô∏è Push failed, continuing with local image"
        echo "‚úÖ API image build completed"
      else
        echo "‚ö†Ô∏è  Registry not available, using local images"
      fi
  only:
    - main
    - merge_requests

# Build Client Image
build_client:
  extends: .docker_job
  stage: build
  script:
    - echo "üî® Building Client image..."
    - docker build -f docker/production/Dockerfile.client -t ${CLIENT_IMAGE}:latest -t ${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA} .
    - |
      if docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASSWORD} ${REGISTRY} 2>/dev/null; then
        docker push ${CLIENT_IMAGE}:latest || echo "‚ö†Ô∏è Push failed, continuing with local image"
        docker push ${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "‚ö†Ô∏è Push failed, continuing with local image"
        echo "‚úÖ Client image build completed"
      else
        echo "‚ö†Ô∏è  Registry not available, using local images"
      fi
  only:
    - main
    - merge_requests

# Deploy to Production (auf dem gleichen Server)
deploy:
  stage: deploy
  script:
    - echo "üöÄ Deploying voting tool..."
    
    # Backup erstellen
    - |
      if [ -f "${DEPLOY_PATH}/docker-compose.yml" ]; then
        cp ${DEPLOY_PATH}/docker-compose.yml ${DEPLOY_PATH}/docker-compose.yml.backup.$(date +%Y%m%d_%H%M%S)
        echo "‚úÖ Backup created"
      fi
      
      # Verzeichnis erstellen falls nicht vorhanden
      mkdir -p ${DEPLOY_PATH}
      
      # Docker-Compose und andere Dateien kopieren
      cp docker/production/docker-compose.yml ${DEPLOY_PATH}/
      
      # .env Datei erstellen mit den neuesten Image Tags
      # Check if registry images are available, otherwise use local images
      if docker pull ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} 2>/dev/null; then
        API_TAG="${API_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        CLIENT_TAG="${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        echo "‚úÖ Using registry images with SHA tags"
      else
        # Tag local images with SHA for deployment
        docker tag ${API_IMAGE}:latest ${API_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "‚ö†Ô∏è Failed to tag API image"
        docker tag ${CLIENT_IMAGE}:latest ${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA} || echo "‚ö†Ô∏è Failed to tag Client image"
        API_TAG="${API_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        CLIENT_TAG="${CLIENT_IMAGE}:${CI_COMMIT_SHORT_SHA}"
        echo "‚úÖ Using locally tagged images with SHA"
      fi
      
      cat > ${DEPLOY_PATH}/.env << EOF
      # Docker Images
      API_IMAGE=${API_TAG}
      CLIENT_IMAGE=${CLIENT_TAG}
      
      # Commit Info for Container Names
      CI_COMMIT_SHORT_SHA=${CI_COMMIT_SHORT_SHA}
      
      # Application Settings
      DOMAIN=${DOMAIN}
      NODE_ENV=production
      
      # Database (wird aus GitLab CI/CD Variablen gelesen)
      DATABASE_HOST=db
      DATABASE_USER=${VOTING_DB_USER:-voting_user}
      DATABASE_PASSWORD=${VOTING_DB_PASSWORD:-voting_password}
      DATABASE_NAME=${VOTING_DB_NAME:-voting_db}
      DATABASE_ROOT_PASSWORD=${VOTING_DB_ROOT_PASSWORD:-root_password}
      
      # JWT Secret
      JWT_SECRET=${VOTING_JWT_SECRET:-voting-jwt-secret-key}
      
      # Email Settings
      EMAIL_HOST=${VOTING_EMAIL_HOST:-smtp.example.com}
      EMAIL_PORT=${VOTING_EMAIL_PORT:-587}
      EMAIL_USER=${VOTING_EMAIL_USER:-noreply@example.com}
      EMAIL_PASSWORD=${VOTING_EMAIL_PASSWORD:-email_password}
      EOF
      
      # Deploy mit docker-compose
      cd ${DEPLOY_PATH}
      docker compose pull || echo "‚ö†Ô∏è Pull failed, using local images"
      docker compose up -d --remove-orphans
      
      # Status anzeigen
      docker ps | grep voting
      echo "‚úÖ Voting tool deployment completed"
  
  environment:
    name: production
    url: https://${DOMAIN}
  when: manual
  only:
    - main
  needs:
    - build_api
    - build_client
  tags:
    - docker
    - deploy

# Rollback Job
rollback:
  stage: deploy
  script:
    - echo "‚è™ Rolling back voting tool..."
    
    # Find latest backup
    - |
      cd ${DEPLOY_PATH}
      latest_backup=$(ls -t docker-compose.yml.backup.* 2>/dev/null | head -1)
      
      if [ -n "$latest_backup" ]; then
        echo "Found backup: $latest_backup"
        cp $latest_backup docker-compose.yml
        docker compose up -d --remove-orphans
        echo "‚úÖ Rollback completed"
      else
        echo "‚ùå No backup found!"
        exit 1
      fi
  when: manual
  only:
    - main
  tags:
    - docker
    - deploy